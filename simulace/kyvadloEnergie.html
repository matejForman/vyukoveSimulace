<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kyvadlo - Demonstrace Zachování Energie</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        
        .container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            background: linear-gradient(to bottom right, #eff6ff, #e0e7ff);
            overflow: hidden;
        }
        
        .title {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 0.75rem;
            color: #312e81;
        }
        
        .grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            min-height: 0;
        }
        
        .panel {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            display: flex;
            flex-direction: column;
        }
        
        .panel-title {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #1f2937;
        }
        
        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .svg-canvas {
            border: 2px solid #d1d5db;
            border-radius: 0.25rem;
            background: #f9fafb;
        }
        
        .controls {
            margin-top: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .btn {
            width: 100%;
            font-weight: 600;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 0.875rem;
        }
        
        .btn-primary {
            background: #4f46e5;
            color: white;
        }
        
        .btn-primary:hover {
            background: #4338ca;
        }
        
        .btn-secondary {
            background: #4b5563;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #374151;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            cursor: pointer;
        }
        
        .checkbox-label input {
            width: 1rem;
            height: 1rem;
        }
        
        .checkbox-label span {
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
        }
        
        .slider-container {
            padding-top: 0.5rem;
        }
        
        .slider-container.bordered {
            border-top: 1px solid #e5e7eb;
        }
        
        .slider-label {
            display: block;
            font-size: 0.75rem;
            font-weight: 500;
            color: #374151;
            margin-bottom: 0.25rem;
        }
        
        .slider {
            width: 100%;
            accent-color: #4f46e5;
        }
        
        .energy-values {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            overflow-y: auto;
        }
        
        .energy-card {
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 2px solid;
        }
        
        .energy-card.green {
            background: #f0fdf4;
            border-color: #86efac;
        }
        
        .energy-card.red {
            background: #fef2f2;
            border-color: #fca5a5;
        }
        
        .energy-card.blue {
            background: #eef2ff;
            border-color: #a5b4fc;
        }
        
        .energy-card.orange {
            background: #fff7ed;
            border-color: #fdba74;
        }
        
        .energy-card.gray {
            background: #f9fafb;
            border-color: #d1d5db;
        }
        
        .energy-label {
            font-size: 0.75rem;
            font-weight: 500;
        }
        
        .energy-label.green { color: #166534; }
        .energy-label.red { color: #991b1b; }
        .energy-label.blue { color: #3730a3; }
        .energy-label.orange { color: #9a3412; }
        
        .energy-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-top: 0.125rem;
        }
        
        .energy-value.green { color: #16a34a; }
        .energy-value.red { color: #dc2626; }
        .energy-value.blue { color: #6366f1; }
        .energy-value.orange { color: #ea580c; }
        
        .energy-formula {
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }
        
        .energy-formula.green { color: #15803d; }
        .energy-formula.red { color: #b91c1c; }
        .energy-formula.blue { color: #4338ca; }
        .energy-formula.orange { color: #c2410c; }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            font-size: 0.75rem;
        }
        
        .info-item-label {
            color: #4b5563;
        }
        
        .info-item-value {
            font-weight: 600;
            color: #1f2937;
        }
        
        .chart-container {
            flex: 1;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #energyChart {
            border: 1px solid #e5e7eb;
            border-radius: 0.25rem;
            background: white;
        }
        
        .info-box {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: #eff6ff;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            color: #1e40af;
        }
        
        .info-box strong {
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function SimpleChart({ data }) {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || data.length === 0) return;

                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;

                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, width, height);

                const maxEnergy = Math.max(...data.map(d => Math.max(d.PE, d.KE, d.Total)), 1);
                const maxTime = Math.max(...data.map(d => d.time), 1);

                const padding = 40;
                const chartWidth = width - 2 * padding;
                const chartHeight = height - 2 * padding;

                ctx.strokeStyle = '#d1d5db';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, height - padding);
                ctx.lineTo(width - padding, height - padding);
                ctx.stroke();

                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 0.5;
                for (let i = 0; i <= 5; i++) {
                    const y = padding + (chartHeight * i / 5);
                    ctx.beginPath();
                    ctx.moveTo(padding, y);
                    ctx.lineTo(width - padding, y);
                    ctx.stroke();
                }

                function drawLine(dataKey, color) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    data.forEach((point, i) => {
                        const x = padding + (point.time / maxTime) * chartWidth;
                        const y = height - padding - (point[dataKey] / maxEnergy) * chartHeight;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    
                    ctx.stroke();
                }

                drawLine('PE', '#10B981');
                drawLine('KE', '#EF4444');
                drawLine('Total', '#6366F1');

                ctx.fillStyle = '#374151';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Čas (s)', width / 2, height - 10);
                ctx.save();
                ctx.translate(15, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Energie (J)', 0, 0);
                ctx.restore();

                const legendY = padding + 10;
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#10B981';
                ctx.fillText('■ PE', width - padding - 90, legendY);
                ctx.fillStyle = '#EF4444';
                ctx.fillText('■ KE', width - padding - 50, legendY);
                ctx.fillStyle = '#6366F1';
                ctx.fillText('■ Celkem', width - padding - 90, legendY + 15);

            }, [data]);

            return <canvas ref={canvasRef} width="480" height="280" id="energyChart" />;
        }

        function PendulumEnergyDemo() {
          const [isRunning, setIsRunning] = useState(false);
          const [state, setState] = useState({
            angle: Math.PI / 3,
            angularVelocity: 0
          });
          const [energyData, setEnergyData] = useState([]);
          const [time, setTime] = useState(0);
          const [withResistance, setWithResistance] = useState(false);
          const [energyLoss, setEnergyLoss] = useState(0);
          const [initialEnergy, setInitialEnergy] = useState(0);
          const [mass, setMass] = useState(1);
          const [lengthMeters, setLengthMeters] = useState(1.8);
          const animationRef = useRef(null);
          const lastTimeRef = useRef(Date.now());
          
          const gravity = 9.81;
          const damping = withResistance ? 0.9995 : 1.0;
          const pixelsPerMeter = 100;
          const length = lengthMeters * pixelsPerMeter;
          const actualLength = lengthMeters;

          const { angle, angularVelocity } = state;
          const height = actualLength * (1 - Math.cos(angle));
          const potentialEnergy = mass * gravity * height;
          const kineticEnergy = 0.5 * mass * Math.pow(angularVelocity * actualLength, 2);
          const totalEnergy = potentialEnergy + kineticEnergy;

          const canvasWidth = 320;
          const canvasHeight = 240;
          const pivotX = canvasWidth / 2;
          const pivotY = 40;

          const bobX = pivotX + length * Math.sin(angle);
          const bobY = pivotY + length * Math.cos(angle);

          useEffect(() => {
            if (isRunning) {
              const animate = () => {
                const currentTime = Date.now();
                let deltaTime = (currentTime - lastTimeRef.current) / 1000;
                lastTimeRef.current = currentTime;
                
                deltaTime = Math.min(deltaTime, 0.05);

                setState(prevState => {
                  const { angle: theta, angularVelocity: omega } = prevState;
                  
                  const accel = (angle) => -(gravity / actualLength) * Math.sin(angle);
                  
                  const k1_v = accel(theta) * deltaTime;
                  const k1_theta = omega * deltaTime;
                  
                  const k2_v = accel(theta + 0.5 * k1_theta) * deltaTime;
                  const k2_theta = (omega + 0.5 * k1_v) * deltaTime;
                  
                  const k3_v = accel(theta + 0.5 * k2_theta) * deltaTime;
                  const k3_theta = (omega + 0.5 * k2_v) * deltaTime;
                  
                  const k4_v = accel(theta + k3_theta) * deltaTime;
                  const k4_theta = (omega + k3_v) * deltaTime;
                  
                  const newAngle = theta + (k1_theta + 2*k2_theta + 2*k3_theta + k4_theta) / 6;
                  const newVelocity = (omega + (k1_v + 2*k2_v + 2*k3_v + k4_v) / 6) * damping;
                  
                  return {
                    angle: newAngle,
                    angularVelocity: newVelocity
                  };
                });

                if (withResistance) {
                  setEnergyLoss(() => {
                    const currentTotal = potentialEnergy + kineticEnergy;
                    const loss = initialEnergy - currentTotal;
                    return loss > 0 ? loss : 0;
                  });
                }

                setTime(prevTime => {
                  const newTime = prevTime + deltaTime;
                  
                  if (Math.floor(newTime * 20) > Math.floor(prevTime * 20)) {
                    setEnergyData(prevData => {
                      const newData = [...prevData, {
                        time: parseFloat(newTime.toFixed(2)),
                        PE: parseFloat(potentialEnergy.toFixed(3)),
                        KE: parseFloat(kineticEnergy.toFixed(3)),
                        Total: parseFloat(totalEnergy.toFixed(3))
                      }];
                      return newData.slice(-200);
                    });
                  }
                  
                  return newTime;
                });

                animationRef.current = requestAnimationFrame(animate);
              };

              lastTimeRef.current = Date.now();
              animationRef.current = requestAnimationFrame(animate);

              return () => {
                if (animationRef.current) {
                  cancelAnimationFrame(animationRef.current);
                }
              };
            }
          }, [isRunning, angularVelocity, angle, potentialEnergy, kineticEnergy, totalEnergy, withResistance, initialEnergy, actualLength, gravity, damping]);

          function toggleSimulation() {
            if (!isRunning) {
              const initialHeight = actualLength * (1 - Math.cos(angle));
              const initialPE = mass * gravity * initialHeight;
              const initialKE = 0.5 * mass * Math.pow(angularVelocity * actualLength, 2);
              setInitialEnergy(initialPE + initialKE);
              setEnergyLoss(0);
            }
            setIsRunning(!isRunning);
          }

          function reset() {
            setIsRunning(false);
            setState({
              angle: Math.PI / 3,
              angularVelocity: 0
            });
            setEnergyData([]);
            setTime(0);
            setEnergyLoss(0);
            setInitialEnergy(0);
            if (animationRef.current) {
              cancelAnimationFrame(animationRef.current);
            }
          }

          function toggleResistance() {
            setWithResistance(!withResistance);
            if (isRunning) {
              setIsRunning(false);
              if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
              }
            }
          }

          function handleMassChange(e) {
            if (!isRunning) {
              setMass(parseFloat(e.target.value));
            }
          }

          function handleLengthChange(e) {
            if (!isRunning) {
              setLengthMeters(parseFloat(e.target.value));
            }
          }

          return (
            <div className="container">
              <h1 className="title">
                Kyvadlo - Zachování Energie
              </h1>

              <div className="grid">
                <div className="panel">
                  <h2 className="panel-title">Pohyb Kyvadla</h2>
                  <div className="canvas-container">
                    <svg width={canvasWidth} height={canvasHeight} className="svg-canvas">
                      <circle cx={pivotX} cy={pivotY} r="4" fill="#374151" />
                      <line x1={pivotX} y1={pivotY} x2={bobX} y2={bobY} stroke="#6B7280" strokeWidth="2" />
                      <circle cx={bobX} cy={bobY} r="16" fill="#3B82F6" stroke="#1E40AF" strokeWidth="2" />
                      <line x1={pivotX} y1={pivotY} x2={pivotX} y2={pivotY + length} stroke="#E5E7EB" strokeWidth="1" strokeDasharray="5,5" />
                      <path d={`M ${pivotX} ${pivotY + 25} A 25 25 0 0 ${angle > 0 ? 1 : 0} ${pivotX + 25 * Math.sin(angle)} ${pivotY + 25 * Math.cos(angle)}`} fill="none" stroke="#10B981" strokeWidth="2" />
                    </svg>
                  </div>

                  <div className="controls">
                    <button onClick={toggleSimulation} className="btn btn-primary">
                      {isRunning ? 'Pauza' : 'Start'}
                    </button>
                    <button onClick={reset} className="btn btn-secondary">
                      Reset
                    </button>
                    <label className="checkbox-label">
                      <input type="checkbox" checked={withResistance} onChange={toggleResistance} />
                      <span>Odpor Vzduchu</span>
                    </label>
                    
                    <div className="slider-container bordered">
                      <label className="slider-label">
                        Hmotnost: {mass.toFixed(1)} kg
                      </label>
                      <input type="range" min="0.5" max="5" step="0.1" value={mass} onChange={handleMassChange} disabled={isRunning} className="slider" />
                    </div>
                    
                    <div className="slider-container">
                      <label className="slider-label">
                        Délka: {lengthMeters.toFixed(1)} m
                      </label>
                      <input type="range" min="0.5" max="2.5" step="0.1" value={lengthMeters} onChange={handleLengthChange} disabled={isRunning} className="slider" />
                    </div>
                  </div>
                </div>

                <div className="panel">
                  <h2 className="panel-title">Hodnoty Energie</h2>
                  <div className="energy-values">
                    <div className="energy-card green">
                      <div className="energy-label green">Potenciální Energie</div>
                      <div className="energy-value green">{potentialEnergy.toFixed(3)} J</div>
                      <div className="energy-formula green">PE = mgh</div>
                    </div>

                    <div className="energy-card red">
                      <div className="energy-label red">Kinetická Energie</div>
                      <div className="energy-value red">{kineticEnergy.toFixed(3)} J</div>
                      <div className="energy-formula red">KE = ½mv²</div>
                    </div>

                    <div className="energy-card blue">
                      <div className="energy-label blue">Celková Energie</div>
                      <div className="energy-value blue">{totalEnergy.toFixed(3)} J</div>
                      <div className="energy-formula blue">Celkem = PE + KE</div>
                    </div>

                    {withResistance && (
                      <div className="energy-card orange">
                        <div className="energy-label orange">Ztráta Energie (Teplo)</div>
                        <div className="energy-value orange">{energyLoss.toFixed(3)} J</div>
                        <div className="energy-formula orange">Rozptýleno: {initialEnergy > 0 ? ((energyLoss/initialEnergy)*100).toFixed(1) : '0.0'}%</div>
                      </div>
                    )}

                    <div className="energy-card gray">
                      <div className="info-grid">
                        <div>
                          <div className="info-item-label">Úhel</div>
                          <div className="info-item-value">{(angle * 180 / Math.PI).toFixed(1)}°</div>
                        </div>
                        <div>
                          <div className="info-item-label">Čas</div>
                          <div className="info-item-value">{time.toFixed(1)} s</div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="panel">
                  <h2 className="panel-title">Energie v Čase</h2>
                  <div className="chart-container">
                    <SimpleChart data={energyData} />
                  </div>
                  <div className="info-box">
                    <strong>Info:</strong> Energie se přeměňuje mezi PE a KE. {withResistance ? 'S odporem celková energie klesá.' : 'Bez odporu je celková energie zachována.'}
                  </div>
                </div>
              </div>
            </div>
          );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<PendulumEnergyDemo />);
    </script>
</body>
</html>
